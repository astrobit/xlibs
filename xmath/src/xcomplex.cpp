#define _USE_MATH_DEFINES
#include <math.h>
#include "xcomplex.h"

xcomplex	xI(0.0,1.0);
////////////////////////////////////////////////////////////////////////////////////////
//
//	xcomplex.cpp
//
//	Source code for xcomplex, as defined in xcomplex.h
//
//	Dependencies:
//		xcomplex.h
//		math.h
//
////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
//
//	operators    (double, XPOLYNOMIAL)
//
////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////////////
//	operator + (double,XPOLYNOMIAL)
////////////////////////////////////////////////////////////////////////////////////////
xcomplex operator +(const double &dLHO, const xcomplex &cRHO)
{
	return (cRHO + dLHO);
}
////////////////////////////////////////////////////////////////////////////////////////
//	operator - (double,XPOLYNOMIAL)
////////////////////////////////////////////////////////////////////////////////////////
xcomplex operator -(const double &dLHO, const xcomplex &cRHO)
{
	return (cRHO * -1 + dLHO);
}
////////////////////////////////////////////////////////////////////////////////////////
//	operator * (double,XPOLYNOMIAL)
////////////////////////////////////////////////////////////////////////////////////////
xcomplex operator *(const double &dLHO, const xcomplex &cRHO)
{
	return (cRHO * dLHO);
}
////////////////////////////////////////////////////////////////////////////////////////
//	operator / (double,XPOLYNOMIAL)
////////////////////////////////////////////////////////////////////////////////////////
xcomplex operator /(const double &dLHO, const xcomplex &cRHO)
{
	xcomplex cLHO(dLHO,0.0);
	return (cLHO / cRHO);
}

////////////////////////////////////////////////////////////////////////////////////////
//
//	sqrt_c
//
////////////////////////////////////////////////////////////////////////////////////////

xcomplex	sqrt_c(const double &dValue)
{
	xcomplex cRet(0,0);
	if (dValue < 0.0)
		cRet.dIm = sqrt(-dValue);
	else
		cRet.dRe = sqrt(dValue);
	return cRet;
}
double		xcomplex::argument( void ) const 
{
	double	dRet;
/*	if( dRe == 0.0)
	{
		if (dIm == 0.0 )
			dRet = 0.0;
		else if (dIm < 0)
			dRet = -M_PI_2;
		else
			dRet = M_PI_2;
	}
	else if (dIm == 0.0)
	{
		if (dRe < 0.0)
			dRet = -M_PI_4;
		else
			dRet = M_PI_4;
	}
	else*/
		dRet = atan2(dIm,dRe);

	return dRet;
}


ostream& operator<<( ostream &out, const xcomplex &xC ) {

	//out << c.real << ( c.imag >= 0 ? "+" : "" ) << c.imag << "I";
	out << xC.dRe << "," << xC.dIm;

	return out;

}

xcomplex	exp(const xcomplex &xcExp)
{
	xcomplex	xcRet(cos(xcExp.dIm),sin(xcExp.dIm));
	xcRet *= exp(xcExp.dRe);
	return xcRet;
}
